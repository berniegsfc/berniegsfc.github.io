<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.4 on Fri Aug  1 08:37:13 2025 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>spdfrest__define.pro (SSC R2.4.14 Web Services API)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="spdfrest__define.pro (SSC R2.4.14 Web Services API)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;</span>
<span class="comments">; NOSA HEADER START</span>
<span class="comments">;</span>
<span class="comments">; The contents of this file are subject to the terms of the NASA Open </span>
<span class="comments">; Source Agreement (NOSA), Version 1.3 only (the "Agreement").  You may </span>
<span class="comments">; not use this file except in compliance with the Agreement.</span>
<span class="comments">;</span>
<span class="comments">; You can obtain a copy of the agreement at</span>
<span class="comments">;   docs/NASA_Open_Source_Agreement_1.3.txt</span>
<span class="comments">; or </span>
<span class="comments">;   https://sscweb.gsfc.nasa.gov/WebServices/NASA_Open_Source_Agreement_1.3.txt.</span>
<span class="comments">;</span>
<span class="comments">; See the Agreement for the specific language governing permissions</span>
<span class="comments">; and limitations under the Agreement.</span>
<span class="comments">;</span>
<span class="comments">; When distributing Covered Code, include this NOSA HEADER in each</span>
<span class="comments">; file and include the Agreement file at </span>
<span class="comments">; docs/NASA_Open_Source_Agreement_1.3.txt.  If applicable, add the </span>
<span class="comments">; following below this NOSA HEADER, with the fields enclosed by </span>
<span class="comments">; brackets "[]" replaced with your own identifying information: </span>
<span class="comments">; Portions Copyright [yyyy] [name of copyright owner}</span>
<span class="comments">;</span>
<span class="comments">; NOSA HEADER END</span>
<span class="comments">;</span>
<span class="comments">; Copyright (c) 2013-2025 United States Government as represented by the</span>
<span class="comments">; National Aeronautics and Space Administration. No copyright is claimed</span>
<span class="comments">; in the United States under Title 17, U.S.Code. All Other Rights </span>
<span class="comments">; Reserved.</span>
<span class="comments">;</span>
<span class="comments">;</span>


<span class="comments">;+</span>
<span class="comments">; This class represents the remotely callable interface to </span>
<span class="comments">; &lt;a href="https://www.nasa.gov/">NASA&lt;/a>'s</span>
<span class="comments">; &lt;a href="https://spdf.gsfc.nasa.gov/">Space Physics Data Facility&lt;/a> </span>
<span class="comments">; (SPDF)</span>
<span class="comments">; &lt;a href="https://en.wikipedia.org/wiki/Web_service#Representational_state_transfer"></span>
<span class="comments">; RESTful Web services&lt;/a>.</span>
<span class="comments">;</span>
<span class="comments">; @copyright Copyright (c) 2013-2025 United States Government as </span>
<span class="comments">;     represented by the National Aeronautics and Space Administration.</span>
<span class="comments">;     No copyright is claimed in the United States under Title 17, </span>
<span class="comments">;     U.S.Code. All Other Rights Reserved.</span>
<span class="comments">;</span>
<span class="comments">; @author B. Harris</span>
<span class="comments">;-</span>


<span class="comments">;+</span>
<span class="comments">; Creates an object representing the SPDF Web service.</span>
<span class="comments">;</span>
<span class="comments">; If access to the Internet is through an HTTP proxy, the caller</span>
<span class="comments">; should ensure that the HTTP_PROXY environment variable is correctly </span>
<span class="comments">; set before this method is called.  The HTTP_PROXY value should be </span>
<span class="comments">; of the form</span>
<span class="comments">; http://username:password@hostname:port/.</span>
<span class="comments">;</span>
<span class="comments">; NOTE: Due to support for the HTTP_PROXY environment variable, this</span>
<span class="comments">; class should not be used in a CGI-like environment where HTTP_PROXY</span>
<span class="comments">; can be set by untrusted entities (see httpoxy vulnerability).</span>
<span class="comments">;</span>
<span class="comments">; @param endpoint {in} {type=string}</span>
<span class="comments">;            URL of SPDF web service.</span>
<span class="comments">; @param version {in} {type=string}</span>
<span class="comments">;            class version.</span>
<span class="comments">; @param currentVersionUrl {in} {type=string}</span>
<span class="comments">;            URL to the file identifying the most up to date version</span>
<span class="comments">;            of this class.</span>
<span class="comments">; @keyword userAgent {in} {optional} {type=string} {default=SscWs}</span>
<span class="comments">;            HTTP user-agent value used in communications with SPDF.</span>
<span class="comments">; @keyword sslVerifyPeer {in} {optional} {type=int} {default=1}</span>
<span class="comments">;            Specifies whether the authenticity of the peer's SSL</span>
<span class="comments">;            certificate should be verified.  When 0, the connection</span>
<span class="comments">;            succeeds regardless of what the peer SSL certificate</span>
<span class="comments">;            contains.</span>
<span class="comments">; @returns a reference to a SSC object.</span>
<span class="comments">;-</span>
<a id="SpdfRest::init:source"></a>function SpdfRest::init, $
    endpoint, $
    version, $
    currentVersionUrl, $
    userAgent = userAgent, $
    sslVerifyPeer = sslVerifyPeer
    compile_opt idl2

    self.endpoint = endpoint
    self.version = version
    self.currentVersionUrl = currentVersionUrl

    self.ssl_verify_peer = self->getDefaultSslVerifyPeer()

    if n_elements(sslVerifyPeer) gt 0 then begin

        self.ssl_verify_peer = sslVerifyPeer
    endif

    if ~keyword_set(userAgent) then userAgent = 'SscWs'

    self.userAgent = 'User-Agent: ' + userAgent + ' (' + $
        !version.os + ' ' + !version.arch + ') IDL/' + !version.release

    http_proxy = getenv('HTTP_PROXY')

    if strlen(http_proxy) gt 0 then begin

        proxyComponents = parse_url(http_proxy)

        self.proxy_hostname = proxyComponents.host
        self.proxy_password = proxyComponents.password
        self.proxy_port = proxyComponents.port
        self.proxy_username = proxyComponents.username

        if strlen(proxy_username) gt 0 then begin

            self.proxy_authentication = 3
        endif
    endif

    self.retryLimit = 50

    return, self
end


<span class="comments">;+</span>
<span class="comments">; Performs cleanup operations when this object is destroyed.</span>
<span class="comments">;-</span>
<a id="SpdfRest::cleanup:source"></a>pro SpdfRest::cleanup
    compile_opt idl2

end


<span class="comments">;+</span>
<span class="comments">; Gets the default value for the IDLnetURL SSL_VERIFY_PEER property </span>
<span class="comments">; based upon the runtime version of IDL.</span>
<span class="comments">;</span>
<span class="comments">; @returns 0 if runtime version of IDL cannot verify new SSL certificates.</span>
<span class="comments">;     Otherwise, 1.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getDefaultSslVerifyPeer:source"></a>function SpdfRest::getDefaultSslVerifyPeer
    compile_opt idl2
<span class="comments">;    compile_opt static when support for IDL &lt; 8.3 is not required</span>

    releaseComponents = strsplit(!version.release, '.', /extract)

    if (releaseComponents[0] lt '7') or $
       (releaseComponents[0] eq '8' and $
        releaseComponents[1] lt '4') then begin

        <span class="comments">; Earlier versions of IDL cannot verify new SSL certificates.</span>

        return, 0
    endif

    return, 1
end


<span class="comments">;+</span>
<span class="comments">; Gets the current endpoint value.</span>
<span class="comments">;</span>
<span class="comments">; @returns current endpoint string value.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getEndpoint:source"></a>function SpdfRest::getEndpoint
    compile_opt idl2

    return, self.endpoint
end


<span class="comments">;+</span>
<span class="comments">; Gets the current userAgent value.</span>
<span class="comments">;</span>
<span class="comments">; @returns current userAgent string value.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getUserAgent:source"></a>function SpdfRest::getUserAgent
    compile_opt idl2

    return, self.userAgent
end

<span class="comments">;+</span>
<span class="comments">; Gets the current defaultDataview value.</span>
<span class="comments">;</span>
<span class="comments">; @returns current defaultDataview string value.</span>
<span class="comments">;-</span>
<a id="SpdfSsc::getDefaultDataview:source"></a>function SpdfSsc::getDefaultDataview
    compile_opt idl2

    return, self.defaultDataview
end


<span class="comments">;+</span>
<span class="comments">; Gets the version of this class.</span>
<span class="comments">;</span>
<span class="comments">; @returns version of this class.</span>
<span class="comments">;-</span>
<a id="SpdfSsc::getVersion:source"></a>function SpdfSsc::getVersion
    compile_opt idl2

    return, self.version
end


<span class="comments">;+</span>
<span class="comments">; Gets the most up to date version of this class.</span>
<span class="comments">;</span>
<span class="comments">; @returns most up to date version of this class.</span>
<span class="comments">;-</span>
<a id="SpdfSsc::getCurrentVersion:source"></a>function SpdfSsc::getCurrentVersion
    compile_opt idl2

    catch, errorStatus
    if (errorStatus ne 0) then begin

        catch, /cancel

        <span class="comments">; Failed to get current version</span>
        return, ''
    endif

    url = obj_new('IDLnetURL', $
                  proxy_authentication = self.proxy_authentication, $
                  proxy_hostname = self.proxy_hostname, $
                  proxy_port = self.proxy_port, $
                  proxy_username = self.proxy_username, $
                  proxy_password = self.proxy_password)

    return, url->get(/string_array, url=self.currentVersionUrl)
end


<span class="comments">;+</span>
<span class="comments">; Compares getVersion() and getCurrentVersion() to determine if this</span>
<span class="comments">; class is up to date.</span>
<span class="comments">;</span>
<span class="comments">; @returns true if getVersion() >= getCurrentVersion().  Otherwise</span>
<span class="comments">;     false.</span>
<span class="comments">;-</span>
<a id="SpdfSsc::isUpToDate:source"></a>function SpdfSsc::isUpToDate
    compile_opt idl2

    version = strsplit(self->getVersion(), '.', /extract)
    versionElements = n_elements(version)
    currentVersion = strsplit(self->getCurrentVersion(), '.', /extract)
    currentVersionElements = n_elements(currentVersion)

    if currentVersionElements eq 0 then begin

        <span class="comments">; Do not know what current version is so return up-to-date</span>
        return, 1
    endif

    if versionElements lt currentVersionElements then begin

        elements = versionElements
    endif else begin

        elements = currentVersionElements
    endelse

    for i = 0, elements - 1 do begin

        if 0 + version[i] lt 0 + currentVersion[i] then return, 0
    endfor

    if versionElements lt currentVersionElements then begin

        return, 0
    endif else begin

        return, 1
    endelse
end


<span class="comments">;+</span>
<span class="comments">; Gets the node's value of the first child of the first item of the</span>
<span class="comments">; specified element of the given DOM document.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param domElement {in} {required} {type=IDLffXMLDOMElement}</span>
<span class="comments">;                DOM element to search.</span>
<span class="comments">; @param tagName {in} {required} {type=string}</span>
<span class="comments">;                A scalar string containing the tag name of the desired</span>
<span class="comments">;                element.</span>
<span class="comments">; @returns strarr containing the node's string value(s) of the first </span>
<span class="comments">;     child of the item(s) of the specified element of the given DOM </span>
<span class="comments">;     document. An empty string is returned if the value cannot be </span>
<span class="comments">;     found.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getNamedElementsFirstChildValue:source"></a>function SpdfRest::getNamedElementsFirstChildValue, $
    domElement, tagName
    compile_opt idl2

    nodeList = domElement->getElementsByTagName(tagName)

    if nodeList->getLength() eq 0 then return, ''

    values = strarr(nodeList->getLength())

    for i = 0, nodeList->getLength() - 1 do begin

        domNode = nodeList->item(i)

        child = domNode->getFirstChild()

        if obj_valid(child) then begin

            values[i] = child->getNodeValue()
        endif else begin

            values[i] = ''
        endelse
    endfor

    if n_elements(values) eq 1 then return, values[0] $
                               else return, values
end


<span class="comments">;+</span>
<span class="comments">; Gets the node's double value of the first child of the first item of </span>
<span class="comments">; the specified element of the given DOM element.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param domElement {in} {required} {type=IDLffXMLDOMElement}</span>
<span class="comments">;                DOM element to search.</span>
<span class="comments">; @param tagName {in} {required} {type=string}</span>
<span class="comments">;                A scalar string containing the tag name of the desired</span>
<span class="comments">;                element.</span>
<span class="comments">; @returns dblarr containing the node's double value(s) of the first </span>
<span class="comments">;     child of the item(s) of the specified element of the given DOM </span>
<span class="comments">;     document. A scalar constant of !values.d_NaN is returned if </span>
<span class="comments">;     the value cannot be found.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getNamedElementsFirstChildDoubleValue:source"></a>function SpdfRest::getNamedElementsFirstChildDoubleValue, $
    domElement, tagName
    compile_opt idl2

    nodeList = domElement->getElementsByTagName(tagName)

    if nodeList->getLength() eq 0 then return, !values.d_NaN

    values = dblarr(nodeList->getLength())

    for i = 0, nodeList->getLength() - 1 do begin

        domNode = nodeList->item(i)

        child = domNode->getFirstChild()

        if obj_valid(child) then begin

            values[i] = double(child->getNodeValue())
        endif else begin

            values[i] = !values.d_NaN
        endelse
    endfor

    if n_elements(values) eq 1 then return, values[0] $
                               else return, values
end


<span class="comments">;+</span>
<span class="comments">; Gets the node's float value of the first child of the first item of </span>
<span class="comments">; the specified element of the given DOM element.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param domElement {in} {required} {type=IDLffXMLDOMElement}</span>
<span class="comments">;                DOM element to search.</span>
<span class="comments">; @param tagName {in} {required} {type=string}</span>
<span class="comments">;                A scalar string containing the tag name of the desired</span>
<span class="comments">;                element.</span>
<span class="comments">; @returns fltarr containing the node's float value(s) of the first </span>
<span class="comments">;     child of the item(s) of the specified element of the given DOM </span>
<span class="comments">;     document. A scalar constant of !values.f_NaN is returned if </span>
<span class="comments">;     the value cannot be found.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getNamedElementsFirstChildFloatValue:source"></a>function SpdfRest::getNamedElementsFirstChildFloatValue, $
    domElement, tagName
    compile_opt idl2

    nodeList = domElement->getElementsByTagName(tagName)

    if nodeList->getLength() eq 0 then return, !values.f_NaN

    values = fltarr(nodeList->getLength())

    for i = 0, nodeList->getLength() - 1 do begin

        domNode = nodeList->item(i)

        child = domNode->getFirstChild()

        if obj_valid(child) then begin

            values[i] = float(child->getNodeValue())
        endif else begin

            values[i] = !values.f_NaN
        endelse
    endfor

    if n_elements(values) eq 1 then return, values[0] $
                               else return, values
end


<span class="comments">;+</span>
<span class="comments">; Converts the given Julian Day value to an ISO 8601 string </span>
<span class="comments">; representation.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param value {in} {type=julDay}</span>
<span class="comments">;            Julian day value to convert.</span>
<span class="comments">; @returns ISO 8601 string representation of the given value</span>
<span class="comments">;-</span>
<a id="SpdfRest::julDay2Iso8601:source"></a>function SpdfRest::julDay2Iso8601, $
    value
    compile_opt idl2

    caldat, value, month, day, year, hour, minute, second

    return, string(year, month, day, hour, minute, second, $
                   format=self.iso8601Format)
end


<span class="comments">;+</span>
<span class="comments">; Creates a SpdfTimeInterval object from a child TimeInterval element</span>
<span class="comments">; of the given node from a cdas:DataResult XML document.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param domNode {in} {type=IDLffXMLDOMNode}</span>
<span class="comments">;              node from a cdas:DataResult XML document.</span>
<span class="comments">; @returns a reference to a SpdfTimeInterval object.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getTimeIntervalChild:source"></a>function SpdfRest::getTimeIntervalChild, $
    domNode
    compile_opt idl2

    timeInterval = obj_new()

    timeIntervalElements = domNode->getElementsByTagName('TimeInterval')

    if timeIntervalElements->getLength() gt 0 then begin

        timeInterval = $
            self->getTimeInterval(timeIntervalElements->item(0))
    end

    return, timeInterval
end


<span class="comments">;+</span>
<span class="comments">; Creates a SpdfTimeInterval object from the given TimeInterval element</span>
<span class="comments">; from a cdas:DataResult XML document.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param timeIntervalElement {in} {type=IDLffXMLDOMNode}</span>
<span class="comments">;              element from a cdas:DataResult XML document.</span>
<span class="comments">; @returns a reference to a SpdfTimeInterval object.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getTimeInterval:source"></a>function SpdfRest::getTimeInterval, $
    timeIntervalElement
    compile_opt idl2

    startDate = $
        self->getJulDate((timeIntervalElement->$
                          getElementsByTagName('Start'))->item(0))

    endDate = $
        self->getJulDate((timeIntervalElement->$
                          getElementsByTagName('End'))->item(0))

    
    return, obj_new('SpdfTimeInterval', startDate, endDate)
end


<span class="comments">;+</span>
<span class="comments">; Creates a julday object from the given time element from a </span>
<span class="comments">; cdas:DataResult XML document.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param dateTimeElement {in} {type=IDLffXMLDOMNodeList}</span>
<span class="comments">;              list whose first child is to be converted into a julday</span>
<span class="comments">; @returns julday representation of first child of given </span>
<span class="comments">;              dateTimeElement.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getJulDate:source"></a>function SpdfRest::getJulDate, $
    dateTimeElement
    compile_opt idl2

    dateFormat='(I4, 1X, I2, 1X, I2, 1X, I2, 1X, I2, 1X, I2)'

    dateTimeStr = (dateTimeElement->getFirstChild())->getNodeValue()

    reads, dateTimeStr, format=dateFormat, $
            year, month, day, hour, minute, second

    return, julday(month, day, year, hour, minute, second)
end


<span class="comments">;+</span>
<span class="comments">; Perform an HTTP GET request to the given URL.  This method provides </span>
<span class="comments">; functionality similar to doing    </span>
<span class="comments">;     obj_new('IDLffXMLDOMDocument', filename=url)</span>
<span class="comments">; except that this method will catch and attempt to deal with errors.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param url {in} {type=string}</span>
<span class="comments">;            URL of GET request to make.</span>
<span class="comments">; @keyword errorReporter {in} {optional} {type=string}</span>
<span class="comments">;              name of IDL procedure to call if an HTTP error occurs.</span>
<span class="comments">; @returns reference to IDLffXMLDOMDocument representation of HTTP</span>
<span class="comments">;     response entity.</span>
<span class="comments">;-</span>
<a id="SpdfRest::makeGetRequest:source"></a>function SpdfRest::makeGetRequest, $
    url, $
    errorReporter = errorReporter
    compile_opt idl2

    username = ''
    password = ''
    retries = 0

    catch, errorStatus
    if (errorStatus ne 0) then begin

        reply = $
            self->handleHttpError( $
                requestUrl, errorReporter = errorReporter)

        obj_destroy, requestUrl

        if reply eq 0 || retries gt self.retryLimit then begin

            catch, /cancel
            return, obj_new()
        endif

        retries = retries + 1

    endif

    requestUrl = self->getRequestUrl(url, username, password)

    result = string(requestUrl->get(/buffer))

    obj_destroy, requestUrl

    return, obj_new('IDLffXMLDOMDocument', string=result)
end


<span class="comments">;+</span>
<span class="comments">; Perform an HTTP POST request to the given URL.  </span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param url {in} {type=string}</span>
<span class="comments">;            URL of GET request to make.</span>
<span class="comments">; @param xmlRequest {in} {type=string}</span>
<span class="comments">;            XML entity body to be include in the request.</span>
<span class="comments">; @keyword errorReporter {in} {optional} {type=string}</span>
<span class="comments">;              name of IDL procedure to call if an HTTP error occurs.</span>
<span class="comments">; @returns reference to IDLffXMLDOMDocument representation of HTTP</span>
<span class="comments">;     response entity.</span>
<span class="comments">;-</span>
<a id="SpdfRest::makePostRequest:source"></a>function SpdfRest::makePostRequest, $
    url, xmlRequest, $
    errorReporter = errorReporter
    compile_opt idl2

    username = ''
    password = ''
    retries = 0

    catch, errorStatus
    if (errorStatus ne 0) then begin

        reply = $
            self->handleHttpError( $
                requestUrl, $
                errorReporter = errorReporter)

        obj_destroy, requestUrl

        if reply eq 0 || retries gt self.retryLimit then begin

            catch, /cancel
            return, obj_new()
        endif

        retries = retries + 1

    endif

    requestUrl = self->getRequestUrl(url, username, password)

    requestUrl->setProperty, header='Content-Type: application/xml'

<span class="comments">; print, 'POSTing ', xmlRequest</span>
<span class="comments">; print, 'to ', url</span>

    result = requestUrl->put(xmlRequest, /buffer, /post, url=url)

    obj_destroy, requestUrl

    return, obj_new('IDLffXMLDOMDocument', filename=result)
end


<span class="comments">;+</span>
<span class="comments">; Function to handle HTTP request errors.  </span>
<span class="comments">; If an errorReporter has been provided, it is called.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param request {in} {type=IDLnetURL}</span>
<span class="comments">;            HTTP request that caused the error.</span>
<span class="comments">; @keyword errorReporter {in} {optional} {type=string}</span>
<span class="comments">;              name of IDL procedure to call if an HTTP error occurs.</span>
<span class="comments">; @returns a value of 1 if corrective action has occurred and a value of</span>
<span class="comments">;     0 if not.  The corrective action for a 429/503 is waiting the</span>
<span class="comments">;     specified time.  The corrective action for a 408 is to wait 30</span>
<span class="comments">;     seconds.</span>
<span class="comments">;-</span>
<a id="SpdfRest::handleHttpError:source"></a>function SpdfRest::handleHttpError, $
    request, $
    errorReporter = errorReporter
    compile_opt idl2

    request->getProperty, $
        response_code=responseCode, $
        response_header=responseHeader, $
        response_filename=responseFilename

    case responseCode of
        429 || 503: begin

            retryAfter = stregex(responseHeader, $
                                 'Retry-After: ([0-9]+)' + string(13b), $
                                 /extract, /subexpr)

            if n_elements(retryAfter) eq 2 && $
               strlen(retryAfter[1]) gt 0 then begin

                wait, fix(retryAfter[1])
            endif
        end
        408: begin

            wait, 30
        end
        else: begin

            if keyword_set(errorReporter) then begin

                call_method, 'reportError', errorReporter, $
                        responseCode, responseHeader, responseFilename
            endif

            return, 0
        end
    endcase

    return, 1
end


<span class="comments">;+</span>
<span class="comments">; Create an IDLnetUrl object from the given URL with any supplied</span>
<span class="comments">; authentication values set.</span>
<span class="comments">;</span>
<span class="comments">; @private</span>
<span class="comments">;</span>
<span class="comments">; @param url {in} {type=string}</span>
<span class="comments">;            URL.</span>
<span class="comments">; @param username {in} {type=string}</span>
<span class="comments">;            username.</span>
<span class="comments">; @param password {in} {type=string}</span>
<span class="comments">;            password.</span>
<span class="comments">; @returns reference to a IDLnetUrl with any supplied authentication</span>
<span class="comments">;     values set.</span>
<span class="comments">;-</span>
<a id="SpdfRest::getRequestUrl:source"></a>function SpdfRest::getRequestUrl, $
    url, username, password
    compile_opt idl2

    requestUrl = $
        obj_new('IDLnetURL', $
                proxy_authentication = self.proxy_authentication, $
                proxy_hostname = self.proxy_hostname, $
                proxy_port = self.proxy_port, $
                proxy_username = self.proxy_username, $
                proxy_password = self.proxy_password, $
                ssl_verify_peer = self.ssl_verify_peer)

    urlComponents = parse_url(url)

    requestUrl->setProperty, $
        header=self.userAgent, $
        url_scheme=urlComponents.scheme, $
        url_host=urlComponents.host, $
        url_port=urlComponents.port, $
        url_path=urlComponents.path, $
        url_query=urlComponents.query

    if username ne '' then begin

        requestUrl->setProperty, $
            authentication=3, $
            url_username=username, $
            url_password=password
    endif

    return, requestUrl
end


<span class="comments">;+</span>
<span class="comments">; Defines the SpdfRest class.</span>
<span class="comments">;</span>
<span class="comments">; @field endpoint URL of SSC web service.</span>
<span class="comments">; @field userAgent HTTP </span>
<span class="comments">;            &lt;a href="http://tools.ietf.org/html/rfc2616#section-14.43"></span>
<span class="comments">;               user-agent value&lt;/a> to use in communications with SSC.</span>
<span class="comments">; @field version identifies the version of this class.</span>
<span class="comments">; @field currentVersionUrl URL to the file identifying the most up to </span>
<span class="comments">;            date version of this class.</span>
<span class="comments">; @field proxy_authentication IDLnetURL PROXY_AUTHENTICATION property</span>
<span class="comments">;            value.</span>
<span class="comments">; @field proxy_hostname IDLnetURL PROXY_HOSTNAME property value.</span>
<span class="comments">; @field proxy_password IDLnetURL PROXY_PASSWORD property value.</span>
<span class="comments">; @field proxy_port IDLnetURL PROXY_PORT property value.</span>
<span class="comments">; @field proxy_username IDLnetURL PROXY_USERNAME property value.</span>
<span class="comments">; @field ssl_verify_peer IDLnetURL SSL_VERIFY_PEER property value.</span>
<span class="comments">; @field retryLimit retry limit for requests that fail with an http</span>
<span class="comments">;            status of 429 or 503 with a Retry-After header.</span>
<span class="comments">;-</span>
<a id="SpdfRest__define:source"></a>pro SpdfRest__define
    compile_opt idl2
    struct = { SpdfRest, $
        endpoint:'', $
        userAgent:'', $
        version:'', $
        currentVersionUrl:'', $
        proxy_authentication:0, $
        proxy_hostname:'', $
        proxy_password:'', $
        proxy_port:'', $
        proxy_username:'', $
        ssl_verify_peer:1, $
        retryLimit:50 $
    }
end
</code>
    </div>
  </body>
</html>